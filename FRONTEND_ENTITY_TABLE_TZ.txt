# Мини-ТЗ: компонент таблицы сущностей CRM (интеграция с Entity API)

**Цель:** добавить на страницу компонент таблицы, в которой пользователь выбирает сущность (сделки, контакты, лиды или смарт-процесс), настраивает видимые поля и смотрит данные в гриде.

**Базовый URL API:** подставляется из конфига. Ниже — примеры с реальным хостом (замените на свой, если нужно).

---

## Реальные адреса вызова API (примеры)

Базовый адрес сервера: **http://194.33.40.197:7070** (в проде подставляйте свой из конфига).

### API 1 — Поля сущности (entity-meta-fields)

Метод: **GET**. Возвращает список полей выбранной сущности (human_title, nested_fields и т.д.).

| Сущность        | URL |
|-----------------|-----|
| Сделки          | http://194.33.40.197:7070/api/entity-meta-fields/?type=deal |
| Контакты        | http://194.33.40.197:7070/api/entity-meta-fields/?type=contact |
| Лиды            | http://194.33.40.197:7070/api/entity-meta-fields/?type=lead |
| Смарт-процесс   | http://194.33.40.197:7070/api/entity-meta-fields/?type=smart_process&entity_key=sp:1114 |

Для смарт-процесса подставляйте свой `entity_key` (sp:1114, sp:1164 и т.д.).

### API 2 — Данные сущности (entity-meta-data)

Метод: **GET**. Возвращает записи для грида: `{ ok, entity_key, type, total, limit, offset, data: [...] }`. Ключи в объектах внутри `data` — это human_title из первого API.

| Сущность        | Пример URL (первая порция) |
|-----------------|----------------------------|
| Сделки          | http://194.33.40.197:7070/api/entity-meta-data/?type=deal&limit=10000&offset=0 |
| Контакты        | http://194.33.40.197:7070/api/entity-meta-data/?type=contact&limit=10000&offset=0 |
| Лиды            | http://194.33.40.197:7070/api/entity-meta-data/?type=lead&limit=10000&offset=0 |
| Смарт-процесс   | http://194.33.40.197:7070/api/entity-meta-data/?type=smart_process&entity_key=sp:1114&limit=10000&offset=0 |

Параметры:
- **type** — обязательно: `deal` | `contact` | `lead` | `smart_process`
- **entity_key** — обязательно для `smart_process`, например `sp:1114`
- **limit** — число записей (макс. 10000 за запрос)
- **offset** — смещение для следующей порции (0, 10000, 20000, …)

Примеры для пагинации «все данные» (лиды, total=25683):
- Первая порция: http://194.33.40.197:7070/api/entity-meta-data/?type=lead&limit=10000&offset=0
- Вторая порция: http://194.33.40.197:7070/api/entity-meta-data/?type=lead&limit=10000&offset=10000
- Третья порция: http://194.33.40.197:7070/api/entity-meta-data/?type=lead&limit=10000&offset=20000

Вызов из кода: подставьте базовый URL из конфига и сформируйте query-строку с нужными `type`, `entity_key`, `limit`, `offset`.

---

## 1. Выбор сущности (первый слой)

### UI
- **Dropdown** (выпадающий список).
- По умолчанию **ничего не выбрано** — пользователь сам выбирает, что смотреть.
- Варианты:
  - **Сделки** → `type=deal`
  - **Контакты** → `type=contact`
  - **Лиды** → `type=lead`
  - **Смарт-процессы** → при выборе нужен второй уровень: список типов (например «Прокат», «Парковка») с соответствующим `entity_key` вида `sp:1114`, `sp:1164` и т.д.

### Логика
- Список смарт-процессов (`entity_key`: `sp:1114`, …) можно взять из другого API (если есть) или из конфига/справочника на фронте.
- После выбора в dropdown сохраняем:
  - `type`: `deal` | `contact` | `lead` | `smart_process`
  - `entity_key`: только для `smart_process` (обязательно), например `sp:1114`.

Эти два параметра используются во **втором** и **третьем** API.

---

## 2. Кнопка «Поля» и список полей (второй API)

### Запрос
- **Метод:** `GET`
- **URL:** `/api/entity-meta-fields/`
- **Query:**
  - `type` — выбранный тип сущности: `deal` | `contact` | `lead` | `smart_process`
  - `entity_key` — только для `type=smart_process`, например `sp:1114`

**Примеры:**
- Сделки: `GET /api/entity-meta-fields/?type=deal`
- Смарт-процесс: `GET /api/entity-meta-fields/?type=smart_process&entity_key=sp:1114`

### Ответ (сокращённо)
```json
{
  "ok": true,
  "entity_key": "deal",
  "type": "deal",
  "fields_count": 250,
  "fields": [
    {
      "id": 1,
      "b24_field": "TITLE",
      "column_name": "TITLE",
      "human_title": "Название",
      "field_type": "string"
    },
    {
      "id": 2,
      "b24_field": "CONTACT_ID",
      "column_name": "CONTACT_ID",
      "human_title": "Контакт",
      "field_type": "crm_contact",
      "nested_fields": [
        { "b24_field": "...", "human_title": "Имя", "field_type": "string" },
        ...
      ]
    },
    ...
  ]
}
```

- У каждого поля есть **`human_title`** — человекочитаемое название (оно же будет ключом в данных из третьего API).
- Поля со ссылкой на другую сущность (контакт, лид и т.д.) содержат **`nested_fields`** — массив полей вложенной сущности.

### UI
1. **Кнопка «Поля»** — доступна после выбора сущности в dropdown. По клику вызывается второй API с текущими `type` и `entity_key`.
2. **Отображение полей:**
   - В **три колонки** (чтобы не одним длинным списком).
   - Показывать и **вложенные поля**: если у поля есть `nested_fields`, отображать их в списке (например, с отступом или отдельной группой), чтобы пользователь мог выбирать и их.
3. **Чекбоксы фильтра по типу сущности:**
   - Три чекбокса: **«Лиды»**, **«Контакты»**, **«Сделки»**.
   - Назначение: показывать/скрывать в списке полей только те поля, которые относятся к выбранным типам (например, поля-привязки к контакту, лиду, сделке и их `nested_fields`).
   - Если чекбокс снят — поля этой сущности в списке не показывать.
4. **Выбор полей для таблицы:** у каждого поля (и при необходимости у вложенного) — чекбокс «показать в таблице». Пользователь отмечает, какие поля должны быть колонками грида. Сохраняем список выбранных **`human_title`** (и/или `column_name` при необходимости) для шага 3.

Итог шага 2: есть выбранная сущность (`type`, `entity_key`) и список выбранных полей (их `human_title`), которые нужно отобразить в гриде.

---

## 3. Данные и грид (третий API)

### Запрос
- **Метод:** `GET`
- **URL:** `/api/entity-meta-data/`
- **Query:**
  - `type` — тот же, что в шаге 1
  - `entity_key` — тот же, что в шаге 1 (для `smart_process` обязателен)
  - `limit` — число записей (например 100, макс. 10000)
  - `offset` — смещение для пагинации

**Пример:**  
`GET /api/entity-meta-data/?type=deal&limit=100&offset=0`

### Ответ (сокращённо)
```json
{
  "ok": true,
  "entity_key": "deal",
  "type": "deal",
  "total": 42150,
  "limit": 100,
  "offset": 0,
  "data": [
    {
      "Название": "+37369160952",
      "Воронка": "Atragere auto",
      "Стадия сделки": "Primul sunet",
      "Контакт": "Vasile",
      "Источник": "Orange Notifications",
      "Тип": "Покупка авто",
      "Выбрать АВТО:": [],
      ...
    },
    ...
  ]
}
```

- **Ключи** в каждом объекте в `data` — это **`human_title`** из второго API (поля уже с человекочитаемыми названиями и расшифрованными значениями: пользователи, контакты, источники, стадии и т.д.).

### UI
1. Вызов третьего API — после того как пользователь выбрал сущность и нажал «Поля» (и при желании выбрал поля). Те же `type` и `entity_key`, что и во втором запросе.
2. **Грид (таблица):**
   - Строки = элементы массива `data`.
   - Колонки = только те поля, которые пользователь выбрал в шаге 2 (по сохранённому списку `human_title`). Остальные ключи из ответа не отображать.
   - Заголовки колонок — соответствующие `human_title`.
   - Пагинация по страницам — см. раздел ниже («Загрузка всех данных и пагинация в гриде»).

---

## Загрузка всех данных и пагинация в гриде

Чтобы пользователь мог листать грид до **последней страницы** (10 или 25 записей на страницу) и видеть **все** данные, нужно сначала забрать с бэкенда все записи, потом показывать их постранично на фронте.

### Шаг 1: Забрать все данные с API

- Один запрос возвращает максимум **10 000** записей (`limit` до 10000).
- В ответе есть поле **`total`** — общее число записей по этой сущности.

**Алгоритм:**

1. Первый запрос:  
   `GET /api/entity-meta-data/?type=...&entity_key=...&limit=10000&offset=0`
2. Из ответа взять **`total`** и массив **`data`**.
3. Если `data.length < total`, делать следующие запросы, увеличивая `offset` на 10000, пока не наберёте `total` записей:
   - второй: `limit=10000&offset=10000`
   - третий: `limit=10000&offset=20000`
   - и т.д.
4. Все полученные массивы **`data`** склеить в один общий массив — это и есть **полный набор записей** для грида.

**Пример (псевдокод):**
```text
fullData = []
offset = 0
pageSize = 10000

повторять:
  ответ = GET .../entity-meta-data/?type=...&limit=10000&offset=offset
  fullData = fullData + ответ.data
  total = ответ.total
  offset = offset + pageSize
пока (offset < total)
```

Можно показывать индикатор загрузки («Загружено N из total») во время этих запросов.

### Шаг 2: Пагинация в гриде (на фронте)

- Хранить **весь** массив записей в состоянии (то, что получили в шаге 1).
- В гриде отображать не весь массив, а только **текущую страницу**: например 10 или 25 строк (выбор пользователя: «10 / 25 / 50 на странице»).
- Текущая страница = срез массива:
  - при размере страницы 10: страница 1 → `fullData.slice(0, 10)`, страница 2 → `fullData.slice(10, 20)`, и т.д.;
  - формула: `fullData.slice((currentPage - 1) * pageSize, currentPage * pageSize)`.
- Под таблицей — блок пагинации:
  - «Страница 1 из N» (где N = `Math.ceil(total / pageSize)`);
  - кнопки «Предыдущая» / «Следующая», при желании номера страниц.
- Переключение страницы = только смена `currentPage` и пересчёт среза; **новых запросов к API не делать** — все данные уже в `fullData`.

Итог: пользователь может выбрать «25 записей на странице» и листать до последней страницы — все записи уже загружены, грид просто показывает нужный кусок массива.

---

## Связь трёх шагов

| Шаг | Действие | Параметры | Результат |
|-----|----------|-----------|-----------|
| 1 | Dropdown «Сущность» | — | `type`, `entity_key` (для смарта) |
| 2 | Кнопка «Поля» → GET entity-meta-fields | `type`, `entity_key` | Список полей в 3 колонки + чекбоксы «Лиды/Контакты/Сделки» + выбор полей для таблицы |
| 3 | Загрузка данных → GET entity-meta-data | `type`, `entity_key`, `limit`, `offset` | Грид: только выбранные колонки, ключи = `human_title` |

Важно: во втором и третьем API всегда передаются одни и те же `type` и `entity_key`; ключи в `data` третьего API совпадают с `human_title` из второго API — по ним и нужно сопоставлять выбранные поля с колонками грида.

---

## Краткая шпаргалка по эндпоинтам

Конкретные примеры URL см. в разделе **«Реальные адреса вызова API»** выше.

- **Поля сущности:**  
  `GET {BASE_URL}/api/entity-meta-fields/?type={deal|contact|lead|smart_process}[&entity_key=sp:1114]`  
  Пример: http://194.33.40.197:7070/api/entity-meta-fields/?type=lead

- **Данные сущности (для грида):**  
  `GET {BASE_URL}/api/entity-meta-data/?type=...&limit=10000&offset=0[&entity_key=sp:1114]`  
  Пример: http://194.33.40.197:7070/api/entity-meta-data/?type=lead&limit=10&offset=0  

  Максимум записей за один запрос: **limit=10000**. Чтобы показать все записи в гриде с пагинацией 10/25 на странице — загрузить все страницы (offset=0, 10000, 20000, …), склеить `data`, затем пагинировать на фронте (см. раздел «Загрузка всех данных и пагинация в гриде»).

Для смарт-процессов `entity_key` обязателен. Ошибки API возвращают HTTP 4xx/5xx и JSON с полем `detail`.
