# ТЗ: страница таблицы сущностей CRM (интеграция с API)

**Цель:** чистая страница с кнопкой «+», форма выбора сущностей, настройка полей (шестерёнка), грид с данными и пагинацией. Всё на основе трёх API.

**Базовый URL:** подставляется из конфига. В примерах используется: **http://194.33.40.197:7070**

---

## Реальные адреса API

| API | Назначение | Метод | Базовый путь |
|-----|-------------|--------|--------------|
| **1. Список сущностей** | Сущности для выбора (контакты, лиды, сделки, воронки, смарт-процессы) | GET | `/api/processes-deals/` |
| **2. Поля сущности** | Список полей выбранной сущности (в т.ч. вложенные) | GET | `/api/entity-meta-fields/` |
| **3. Данные сущности** | Записи для грида (значения полей) | GET | `/api/entity-meta-data/` |

---

# 1. Стартовая страница и форма выбора сущностей

## 1.0 Состояние после создания страницы

- Отображается **чистая страница**.
- На ней только **значок плюса** (иконка «+»). Текст «New Task» или кнопку с текстом **не показывать** — только плюс.
- По **нажатию на плюс** открывается **модальная форма** с выбором сущностей.

## 1.1 Форма выбора сущностей (чекбоксы)

В форме должны быть **чекбоксы**:

1. **Контакты** — один пункт.
2. **Лиды** — один пункт.
3. **Сделки** — с разбивкой по **воронкам** (см. п. 1.1.1).
4. **Смарт-процессы** — с возможностью выбрать **несколько** конкретных смарт-процессов (см. п. 1.1.2).

Данные для этой формы берутся из **первого API**.

### Первое API — получение списка сущностей

- **Метод:** `GET`
- **URL:** `{BASE_URL}/api/processes-deals/`
- **Пример:** `http://194.33.40.197:7070/api/processes-deals/`
- **Тело запроса:** не требуется.
- **Query-параметры:** нет.

**Пример ответа:**

```json
{
  "ok": true,
  "entities": [
    {
      "type": "smart_process",
      "entity_key": "sp:1114",
      "entity_type_id": 1114,
      "title": "Название смарт-процесса",
      "total": 150
    },
    {
      "type": "deal",
      "entity_key": "deal",
      "entity_type_id": null,
      "title": "CRM Deal",
      "total": 42150
    },
    {
      "type": "contact",
      "entity_key": "contact",
      "entity_type_id": null,
      "title": "CRM Contact",
      "total": 36264
    },
    {
      "type": "lead",
      "entity_key": "lead",
      "entity_type_id": null,
      "title": "CRM Lead",
      "total": 25683
    }
  ]
}
```

**Как использовать:**

- Пройти по массиву `entities`.
- Для каждого элемента с `type === "contact"` — один чекбокс **«Контакты»** (или использовать `title`).
- Для каждого с `type === "lead"` — один чекбокс **«Лиды»**.
- Для каждого с `type === "deal"` — пункт **«Сделки»**; внутри него показывать **воронки** (п. 1.1.1).
- Для всех с `type === "smart_process"` — группа **«Смарт-процессы»** с чекбоксом по каждому элементу (п. 1.1.2).
- При выборе сохранять: `type`, `entity_key` (для смарт-процесса — из ответа, например `sp:1114`). Для сделки с воронкой — дополнительно `category_id` (если бэкенд отдаёт воронки, см. ниже).

В форме должна быть кнопка **«Сохранить»**. По нажатию форма закрывается, сохраняются выбранные сущности (одна или несколько — в зависимости от логики: одна выбранная сущность для одной таблицы или несколько).

### 1.1.1 Сделки по воронкам

- Сделки должны отображаться **с разбивкой по воронкам**.
- В первом API (`/api/processes-deals/`) сделки приходят **одним пунктом** (`type: "deal"`, `entity_key: "deal"`). Список воронок этим API **не отдаётся**.
- **Вариант A:** если бэкенд добавит в ответ `deal_funnels` или отдельный эндпоинт списка воронок (например `GET /api/deal-categories/`), фронт запрашивает список воронок и под пунктом «Сделки» показывает чекбоксы по каждой воронке; при выборе сохраняется `type=deal`, `entity_key=deal`, `category_id=<id воронки>`.
- **Вариант B (пока):** под «Сделки» один чекбокс «Сделки» без разбивки; сохраняются `type=deal`, `entity_key=deal`. После появления API воронок — доработать отображение и передачу `category_id` в запросы данных (если бэкенд добавит фильтр по воронке).

### 1.1.2 Смарт-процессы

- В ответе первого API в `entities` приходят все смарт-процессы (`type === "smart_process"`).
- В форме в блоке **«Смарт-процессы»** выводить **чекбокс на каждый** смарт-процесс: подставлять `title` и при выборе сохранять `entity_key` (например `sp:1114`, `sp:1164`).
- Пользователь может выбрать **несколько** смарт-процессов (если по ТЗ нужна одна таблица на одну сущность — тогда один выбор; если разрешено несколько сущностей — несколько чекбоксов).

---

# 2. Второе API — поля сущности (форма «шестерёнка»)

## 2.0 Когда показывать

- **Над гридом** — иконка **шестерёнки**. По нажатию открывается форма со списком полей для настройки колонок грида.

## 2.1 Запрос ко второму API

Данные для формы полей берутся из **второго API**. В запрос передаются **те же `type` и `entity_key`**, которые получены из первого API и сохранены при нажатии «Сохранить» в форме выбора сущностей.

- **Метод:** `GET`
- **URL:** `{BASE_URL}/api/entity-meta-fields/`
- **Query-параметры:**
  - `type` — обязательно: `deal` | `contact` | `lead` | `smart_process`
  - `entity_key` — **обязательно только для `type=smart_process`**, например `sp:1114`

**Примеры:**

- Сделки:  
  `GET http://194.33.40.197:7070/api/entity-meta-fields/?type=deal`
- Контакты:  
  `GET http://194.33.40.197:7070/api/entity-meta-fields/?type=contact`
- Лиды:  
  `GET http://194.33.40.197:7070/api/entity-meta-fields/?type=lead`
- Смарт-процесс:  
  `GET http://194.33.40.197:7070/api/entity-meta-fields/?type=smart_process&entity_key=sp:1114`

**Связь с первым API:** значение `type` и при необходимости `entity_key` берутся из сохранённого выбора пользователя (форма по кнопке «+»). Без выбранной сущности запрос ко второму API не выполнять (или показывать сообщение «Сначала выберите сущность»).

## 2.2 Ответ второго API (сокращённо)

```json
{
  "ok": true,
  "entity_key": "deal",
  "type": "deal",
  "fields_count": 250,
  "fields": [
    {
      "id": 1,
      "b24_field": "TITLE",
      "column_name": "title",
      "human_title": "Название",
      "field_type": "string"
    },
    {
      "id": 2,
      "b24_field": "CONTACT_ID",
      "column_name": "contact_id",
      "human_title": "Контакт",
      "field_type": "crm_contact",
      "nested_fields": [
        { "b24_field": "NAME", "human_title": "Имя", "field_type": "string" },
        { "b24_field": "LAST_NAME", "human_title": "Фамилия", "field_type": "string" }
      ]
    }
  ]
}
```

- У каждого поля есть **`human_title`** — это ключ в объектах данных третьего API.
- Поля со ссылкой на другую сущность (контакт, лид, компания, смарт-процесс) содержат **`nested_fields`** — массив полей вложенной сущности.

## 2.3 Форма полей (по нажатию шестерёнки)

### Чекбоксы вложенностей вверху формы

- **Вверху** формы — чекбоксы: **Лиды**, **Контакты**, **Сделки**, **Компании**, **Смарт-процессы**.
- Показывать **только те** чекбоксы, для которых в ответе второго API есть хотя бы одно поле с вложенностью этого типа (т.е. поле с `nested_fields`, соответствующее лидам/контактам/сделкам/компаниям/смарт-процессам). Если вложенностей нет — блок с этими чекбоксами не показывать.
- При **включении** чекбокса — в списке полей показываются поля основной сущности и **вложенные поля** выбранного типа (из `nested_fields`).
- При **снятии** чекбокса — вложенные поля этого типа в списке **не показывать**.

### Список полей

- Поля выводить **в три колонки** (сетка 3 колонки).
- Если включена вложенность — группировать по типу сущности, например:

  **Лиды:**  
  - поле 1  
  - поле 2  

  **Контакты:**  
  - поле 1  
  - поле 2  

  **Сделки:**  
  - поле 1  

  **Компании:**  
  - поле 1  

  **Смарт-процессы (sp:1114):**  
  - поле 1  

- У каждого поля — чекбокс «показать в таблице». Сохранять список выбранных **`human_title`** (и при необходимости `column_name`) для отображения колонок в гриде.

Итог шага 2: есть выбранная сущность (`type`, `entity_key`) и список выбранных полей (их `human_title`), которые станут колонками грида.

---

# 3. Третье API — данные для грида

## 3.1 Запрос к третьему API

Используются **те же `type` и `entity_key`**, что и во втором API (из сохранённого выбора сущности).

- **Метод:** `GET`
- **URL:** `{BASE_URL}/api/entity-meta-data/`
- **Query-параметры:**
  - `type` — обязательно: `deal` | `contact` | `lead` | `smart_process`
  - `entity_key` — обязательно для `type=smart_process`, например `sp:1114`
  - `limit` — число записей за запрос (1–10000)
  - `offset` — смещение для пагинации (0, 10000, 20000, …)

**Примеры:**

- Сделки (первая порция):  
  `GET http://194.33.40.197:7070/api/entity-meta-data/?type=deal&limit=10000&offset=0`
- Контакты:  
  `GET http://194.33.40.197:7070/api/entity-meta-data/?type=contact&limit=10000&offset=0`
- Смарт-процесс:  
  `GET http://194.33.40.197:7070/api/entity-meta-data/?type=smart_process&entity_key=sp:1114&limit=10000&offset=0`

**Связь со вторым API:** `type` и `entity_key` те же, что передавались в `/api/entity-meta-fields/`. Ключи в объектах внутри `data` ответа третьего API — это **`human_title`** из второго API; по ним сопоставлять выбранные поля с колонками грида.

## 3.2 Ответ третьего API (сокращённо)

```json
{
  "ok": true,
  "entity_key": "deal",
  "type": "deal",
  "total": 42150,
  "limit": 10000,
  "offset": 0,
  "data": [
    {
      "Название": "Сделка 1",
      "Воронка": "Atragere auto",
      "Стадия сделки": "Primul sunet",
      "Контакт": "Vasile",
      "Источник": "Orange Notifications",
      "ID": 12345
    }
  ]
}
```

- **Ключи** в объектах в `data` — те же **`human_title`**, что в полях второго API.
- В гриде отображать только колонки по **выбранным в форме полей** `human_title`; остальные ключи можно не показывать.

---

# 4. Пагинация: как получить все данные и как отображать грид

За один запрос третьего API возвращается не более **10 000** записей (`limit` до 10000). В ответе поле **`total`** — общее количество записей по данной сущности.

## 4.1 Получение всех данных через пагинацию API

Чтобы на гриде были доступны **все** записи (не только 10 и не только 1000), нужно забирать данные **несколькими запросами** с пагинацией:

1. Первый запрос:  
   `GET .../api/entity-meta-data/?type=...&entity_key=...&limit=10000&offset=0`
2. Из ответа взять **`total`** и массив **`data`**.
3. Если `data.length < total`, выполнять следующие запросы, увеличивая `offset` на 10000, пока не будет загружено `total` записей:
   - второй: `limit=10000&offset=10000`
   - третий: `limit=10000&offset=20000`
   - и т.д.
4. Все массивы **`data`** объединить в один общий массив — это **полный набор записей** для грида.

**Псевдокод:**

```
fullData = []
offset = 0
pageSize = 10000

повторять:
  ответ = GET .../api/entity-meta-data/?type=...&entity_key=...&limit=10000&offset=offset
  fullData = fullData.concat(ответ.data)
  total = ответ.total
  offset = offset + pageSize
пока (offset < total)
```

Рекомендуется показывать индикатор загрузки («Загружено N из total») во время этих запросов.

## 4.2 Пагинация в гриде (на фронте)

- Хранить **весь** массив записей в состоянии (результат шага 4.1).
- В гриде отображать не весь массив, а **текущую страницу**, например 10, 25 или 50 строк на страницу (настройка пользователя).
- Текущая страница — срез массива:  
  `fullData.slice((currentPage - 1) * pageSize, currentPage * pageSize)`.
- Под таблицей — блок пагинации: «Страница 1 из N», кнопки «Предыдущая» / «Следующая», при необходимости номера страниц.
- Переключение страницы — только смена `currentPage` и пересчёт среза; **дополнительных запросов к API не делать** — все данные уже в `fullData`.

Итог: пользователь может выбрать «25 записей на странице» и листать до последней страницы; все записи подгружаются с бэкенда пагинацией по 10000, затем отображаются постранично на фронте.

---

# 5. Сводка: связь трёх API

| Шаг | Действие | Откуда параметры | API | Результат |
|-----|----------|-------------------|-----|-----------|
| 1 | Нажатие «+» → форма с чекбоксами сущностей | — | GET `/api/processes-deals/` | Список: контакты, лиды, сделки (по воронкам при наличии API), смарт-процессы. Выбор → сохраняем `type`, `entity_key` |
| 2 | Нажатие шестерёнки → форма полей | `type`, `entity_key` из шага 1 | GET `/api/entity-meta-fields/?type=...&entity_key=...` | Список полей в 3 колонки, чекбоксы вложенностей (Лиды/Контакты/Сделки/Компании/Смарты), выбор полей для таблицы → сохраняем список `human_title` |
| 3 | Загрузка данных для грида | `type`, `entity_key` из шага 1 | GET `/api/entity-meta-data/?type=...&entity_key=...&limit=10000&offset=...` | Массив записей; ключи в объектах = `human_title` из шага 2. Пагинация по 10000 до полной загрузки, затем постраничный вывод в гриде |

**Важно:** во втором и третьем API всегда передаются одни и те же `type` и `entity_key`; ключи в `data` третьего API совпадают с `human_title` из второго API — по ним сопоставлять выбранные поля с колонками грида.

---

# 6. Краткая шпаргалка по эндпоинтам

- **Список сущностей:**  
  `GET {BASE_URL}/api/processes-deals/`  
  Пример: http://194.33.40.197:7070/api/processes-deals/

- **Поля сущности:**  
  `GET {BASE_URL}/api/entity-meta-fields/?type={deal|contact|lead|smart_process}[&entity_key=sp:1114]`  
  Пример: http://194.33.40.197:7070/api/entity-meta-fields/?type=lead

- **Данные сущности (для грида):**  
  `GET {BASE_URL}/api/entity-meta-data/?type=...&limit=10000&offset=0[&entity_key=sp:1114]`  
  Пример: http://194.33.40.197:7070/api/entity-meta-data/?type=lead&limit=10000&offset=0  

  Максимум за один запрос: **limit=10000**. Чтобы показать все записи с пагинацией 10/25/50 на странице — загрузить все порции (offset=0, 10000, 20000, …), объединить `data`, затем пагинировать на фронте (раздел 4).

Для смарт-процессов параметр `entity_key` обязателен. Ошибки API возвращают HTTP 4xx/5xx и JSON с полем `detail`.
