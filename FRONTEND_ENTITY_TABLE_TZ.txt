# ТЗ: страница таблицы сущностей CRM (интеграция с API)

**Цель:** чистая страница с кнопкой «+», форма выбора сущностей, настройка полей (шестерёнка), грид с данными и пагинацией. Всё на основе трёх API.

**Базовый URL:** подставляется из конфига. В примерах используется: **http://194.33.40.197:7070**

---

## Реальные адреса API

| API | Назначение | Метод | Базовый путь |
|-----|-------------|--------|--------------|
| **1. Список сущностей** | Сущности для выбора (контакты, лиды, сделки, воронки, смарт-процессы) | GET | `/api/processes-deals/` |
| **2. Поля сущности** | Список полей выбранной сущности (в т.ч. вложенные) | GET | `/api/entity-meta-fields/` |
| **3. Данные сущности** | Записи для грида (значения полей) | GET | `/api/entity-meta-data/` |

---

# 1. Стартовая страница и форма выбора сущностей

## 1.0 Состояние после создания страницы

- Отображается **чистая страница**.
- На ней только **значок плюса** (иконка «+»). Текст «New Task» или кнопку с текстом **не показывать** — только плюс.
- По **нажатию на плюс** открывается **модальная форма** с выбором сущностей.

## 1.1 Форма выбора сущностей (radio)

В форме — **radio-кнопки** (выбор одной сущности за одно открытие модалки). Разрешён **мультивыбор в одном гриде**: пользователь может несколько раз нажать «+», каждый раз выбрать одну сущность (radio) и сохранить — в гриде будут данные по всем выбранным сущностям.

1. **Контакты** — один пункт (radio).
2. **Лиды** — один пункт (radio).
3. **Сделки** — заголовок **жирным**, под ним **radio** по воронкам (одна воронка = её сделки) или один пункт «Сделки», если API воронок нет (п. 1.1.1).
4. **Смарт-процессы** — заголовок **жирным**, под ним **radio** по каждому смарт-процессу (один смарт-процесс за выбор) (п. 1.1.2).

Данные для этой формы берутся из **первого API**.

### Первое API — получение списка сущностей

- **Метод:** `GET`
- **URL:** `{BASE_URL}/api/processes-deals/`
- **Пример:** `http://194.33.40.197:7070/api/processes-deals/`
- **Тело запроса:** не требуется.
- **Query-параметры:** нет.

**Пример ответа:**

```json
{
  "ok": true,
  "entities": [
    {
      "type": "smart_process",
      "entity_key": "sp:1114",
      "entity_type_id": 1114,
      "title": "Название смарт-процесса",
      "total": 150
    },
    {
      "type": "deal",
      "entity_key": "deal",
      "entity_type_id": null,
      "title": "CRM Deal",
      "total": 42150
    },
    {
      "type": "contact",
      "entity_key": "contact",
      "entity_type_id": null,
      "title": "CRM Contact",
      "total": 36264
    },
    {
      "type": "lead",
      "entity_key": "lead",
      "entity_type_id": null,
      "title": "CRM Lead",
      "total": 25683
    }
  ]
}
```

**Как использовать:**

- Пройти по массиву `entities`.
- Для каждого элемента с `type === "contact"` — один пункт **«Контакты»** (radio).
- Для каждого с `type === "lead"` — один пункт **«Лиды»** (radio).
- Для каждого с `type === "deal"` — блок с **жирным заголовком «Сделки»**; внутри — **radio** по воронкам (п. 1.1.1) или один radio «Сделки», если воронок нет.
- Для всех с `type === "smart_process"` — блок с **жирным заголовком «Смарт-процессы»**; внутри — **radio** по каждому смарт-процессу (п. 1.1.2).
- При выборе сохранять: `type`, `entity_key` (для смарт-процесса — из ответа, например `sp:1114`). Для сделки с воронкой — дополнительно `category_id` (если бэкенд отдаёт воронки).
- За одно нажатие «Сохранить» добавляется **одна** выбранная сущность в список для грида; модалку можно открыть снова и добавить ещё сущности (мультивыбор).

В форме должна быть кнопка **«Сохранить»**. По нажатию форма закрывается, выбранная сущность (одна, по radio) добавляется в список сущностей грида.

### 1.1.1 Сделки по воронкам

- Сделки отображаются с **жирным заголовком «Сделки»** и **radio-списком**.
- В первом API (`/api/processes-deals/`) сделки приходят **одним пунктом** (`type: "deal"`, `entity_key: "deal"`). Список воронок этим API **не отдаётся**.
- **Вариант A:** если бэкенд добавит в ответ `deal_funnels` или эндпоинт воронок (например `GET /api/deal-categories/`), под «Сделки» показывать **radio по каждой воронке**; при выборе сохранять `type=deal`, `entity_key=deal`, `category_id=<id воронки>`.
- **Вариант B (пока):** под «Сделки» один **radio** «Сделки»; сохраняются `type=deal`, `entity_key=deal`. После появления API воронок — доработать.

### 1.1.2 Смарт-процессы

- В ответе первого API в `entities` приходят все смарт-процессы (`type === "smart_process"`).
- В форме блок **«Смарт-процессы»** — **жирный заголовок**, под ним **radio на каждый** смарт-процесс (подставлять `title`); при выборе сохранять `entity_key` (например `sp:1114`).
- За одно открытие модалки выбирается **один** смарт-процесс (radio); добавить в грид ещё смарты можно повторным открытием «+» и выбором другого.

---

# 2. Второе API — поля сущности (форма «шестерёнка»)

## 2.0 Когда показывать

- **Над гридом** — иконка **шестерёнки**. По нажатию открывается форма со списком полей для настройки колонок грида.

## 2.1 Запрос ко второму API

Данные для формы полей берутся из **второго API**. В запрос передаются **те же `type` и `entity_key`**, которые получены из первого API и сохранены при нажатии «Сохранить» в форме выбора сущностей.

- **Метод:** `GET`
- **URL:** `{BASE_URL}/api/entity-meta-fields/`
- **Query-параметры:**
  - `type` — обязательно: `deal` | `contact` | `lead` | `smart_process`
  - `entity_key` — **обязательно только для `type=smart_process`**, например `sp:1114`

**Примеры:**

- Сделки:  
  `GET http://194.33.40.197:7070/api/entity-meta-fields/?type=deal`
- Контакты:  
  `GET http://194.33.40.197:7070/api/entity-meta-fields/?type=contact`
- Лиды:  
  `GET http://194.33.40.197:7070/api/entity-meta-fields/?type=lead`
- Смарт-процесс:  
  `GET http://194.33.40.197:7070/api/entity-meta-fields/?type=smart_process&entity_key=sp:1114`

**Связь с первым API:** значение `type` и при необходимости `entity_key` берутся из сохранённого выбора пользователя (форма по кнопке «+»). Без выбранной сущности запрос ко второму API не выполнять (или показывать сообщение «Сначала выберите сущность»).

## 2.2 Ответ второго API (сокращённо)

```json
{
  "ok": true,
  "entity_key": "deal",
  "type": "deal",
  "fields_count": 250,
  "fields": [
    {
      "id": 1,
      "b24_field": "TITLE",
      "column_name": "title",
      "human_title": "Название",
      "field_type": "string"
    },
    {
      "id": 2,
      "b24_field": "CONTACT_ID",
      "column_name": "contact_id",
      "human_title": "Контакт",
      "field_type": "crm_contact",
      "nested_fields": [
        { "b24_field": "NAME", "human_title": "Имя", "field_type": "string" },
        { "b24_field": "LAST_NAME", "human_title": "Фамилия", "field_type": "string" }
      ]
    }
  ]
}
```

- У каждого поля есть **`human_title`** — это ключ в объектах данных третьего API.
- Поля со ссылкой на другую сущность (контакт, лид, компания, смарт-процесс) содержат **`nested_fields`** — массив полей вложенной сущности.

## 2.3 Форма полей (по нажатию шестерёнки)

### Чекбоксы вложенностей вверху формы

- **Вверху** формы — чекбоксы: **Лиды**, **Контакты**, **Сделки**, **Компании**, **Смарт-процессы**.
- Показывать **только те** чекбоксы, для которых в ответе второго API есть хотя бы одно поле с вложенностью этого типа (поле с `nested_fields`). Если вложенностей нет — блок не показывать.
- При **включении** чекбокса — в списке полей показываются поля основной сущности и **вложенные поля** этого типа (чтобы пользователь мог выбрать, показывать ли их в гриде).
- При **снятии** чекбокса — вложенные поля этого типа в списке **не показывать** (в гриде они не появятся).

### Список полей

- Поля выводить **в три колонки** (сетка 3 колонки).
- Если включена вложенность — группировать по типу сущности, например:

  **Лиды:**  
  - поле 1  
  - поле 2  

  **Контакты:**  
  - поле 1  
  - поле 2  

  **Сделки:**  
  - поле 1  

  **Компании:**  
  - поле 1  

  **Смарт-процессы (sp:1114):**  
  - поле 1  

- У каждого поля — чекбокс «показать в таблице». Сохранять список выбранных **`human_title`** (и при необходимости `column_name`) для отображения колонок в гриде.

Итог шага 2: есть выбранная сущность (`type`, `entity_key`) и список выбранных полей (их `human_title`), которые станут колонками грида.

---

# 3. Третье API — данные для грида

## 3.1 Запрос к третьему API

Используются **те же `type` и `entity_key`**, что и во втором API (из сохранённого выбора сущности).

- **Метод:** `GET`
- **URL:** `{BASE_URL}/api/entity-meta-data/`
- **Query-параметры:**
  - `type` — обязательно: `deal` | `contact` | `lead` | `smart_process`
  - `entity_key` — обязательно для `type=smart_process`, например `sp:1114`
  - `limit` — число записей за запрос (1–10000)
  - `offset` — смещение для пагинации (0, 10000, 20000, …)

**Примеры:**

- Сделки (первая порция):  
  `GET http://194.33.40.197:7070/api/entity-meta-data/?type=deal&limit=10000&offset=0`
- Контакты:  
  `GET http://194.33.40.197:7070/api/entity-meta-data/?type=contact&limit=10000&offset=0`
- Смарт-процесс:  
  `GET http://194.33.40.197:7070/api/entity-meta-data/?type=smart_process&entity_key=sp:1114&limit=10000&offset=0`

**Связь со вторым API:** `type` и `entity_key` те же, что передавались в `/api/entity-meta-fields/`. Ключи в объектах внутри `data` ответа третьего API — это **`human_title`** из второго API; по ним сопоставлять выбранные поля с колонками грида.

## 3.2 Ответ третьего API (сделки — пример структуры)

Ключи в объектах в `data` — **плоские**, совпадают с **`human_title`** из второго API (в т.ч. вложенные поля отображаются как одна строка, например «Контакт»: `"MATEI DUMITRU"`).

**Пример фрагмента ответа для сделок:**

```json
{
  "ok": true,
  "entity_key": "deal",
  "type": "deal",
  "total": 42263,
  "limit": 10,
  "offset": 0,
  "data": [
    {
      "Название": "Сделка #91228",
      "Воронка": "Сделки - прокат",
      "Стадия сделки": "In chirie",
      "Контакт": "MATEI DUMITRU",
      "Источник": null,
      "ID": 91228,
      "Дата создания": "2026-02-04T11:16:25Z",
      "Сумма": 4000,
      "Валюта": "MDL"
    }
  ]
}
```

- В гриде отображать только колонки по **выбранным в форме полей** `human_title`; остальные ключи можно не показывать.
- Значения могут быть `null`, строка, число, массив, объект (например для файлов/фото).

---

# 4. Пагинация: как получить все данные и как отображать грид

За один запрос третьего API возвращается не более **10 000** записей (`limit` до 10000). В ответе поле **`total`** — общее количество записей по данной сущности.

## 4.1 Получение всех данных через пагинацию API

Чтобы на гриде были доступны **все** записи (не только 10 и не только 1000), нужно забирать данные **несколькими запросами** с пагинацией:

1. Первый запрос:  
   `GET .../api/entity-meta-data/?type=...&entity_key=...&limit=10000&offset=0`
2. Из ответа взять **`total`** и массив **`data`**.
3. Если `data.length < total`, выполнять следующие запросы, увеличивая `offset` на 10000, пока не будет загружено `total` записей:
   - второй: `limit=10000&offset=10000`
   - третий: `limit=10000&offset=20000`
   - и т.д.
4. Все массивы **`data`** объединить в один общий массив — это **полный набор записей** для грида.

**Псевдокод:**

```
fullData = []
offset = 0
pageSize = 10000

повторять:
  ответ = GET .../api/entity-meta-data/?type=...&entity_key=...&limit=10000&offset=offset
  fullData = fullData.concat(ответ.data)
  total = ответ.total
  offset = offset + pageSize
пока (offset < total)
```

Рекомендуется показывать индикатор загрузки («Загружено N из total») во время этих запросов.

## 4.2 Пагинация в гриде (на фронте)

- Хранить **весь** массив записей в состоянии (результат шага 4.1).
- В гриде отображать не весь массив, а **текущую страницу**, например 10, 25 или 50 строк на страницу (настройка пользователя).
- Текущая страница — срез массива:  
  `fullData.slice((currentPage - 1) * pageSize, currentPage * pageSize)`.
- Под таблицей — блок пагинации: «Страница 1 из N», кнопки «Предыдущая» / «Следующая», при необходимости номера страниц.
- Переключение страницы — только смена `currentPage` и пересчёт среза; **дополнительных запросов к API не делать** — все данные уже в `fullData`.

Итог: пользователь может выбрать «25 записей на странице» и листать до последней страницы; все записи подгружаются с бэкенда пагинацией по 10000, затем отображаются постранично на фронте.

---

# 5. Сводка: связь трёх API

| Шаг | Действие | Откуда параметры | API | Результат |
|-----|----------|-------------------|-----|-----------|
| 1 | Нажатие «+» → форма с чекбоксами сущностей | — | GET `/api/processes-deals/` | Список: контакты, лиды, сделки (по воронкам при наличии API), смарт-процессы. Выбор → сохраняем `type`, `entity_key` |
| 2 | Нажатие шестерёнки → форма полей | `type`, `entity_key` из шага 1 | GET `/api/entity-meta-fields/?type=...&entity_key=...` | Список полей в 3 колонки, чекбоксы вложенностей (Лиды/Контакты/Сделки/Компании/Смарты), выбор полей для таблицы → сохраняем список `human_title` |
| 3 | Загрузка данных для грида | `type`, `entity_key` из шага 1 | GET `/api/entity-meta-data/?type=...&entity_key=...&limit=10000&offset=...` | Массив записей; ключи в объектах = `human_title` из шага 2. Пагинация по 10000 до полной загрузки, затем постраничный вывод в гриде |

**Важно:** во втором и третьем API всегда передаются одни и те же `type` и `entity_key`; ключи в `data` третьего API совпадают с `human_title` из второго API — по ним сопоставлять выбранные поля с колонками грида.

---

# 6. Краткая шпаргалка по эндпоинтам

- **Список сущностей:**  
  `GET {BASE_URL}/api/processes-deals/`  
  Пример: http://194.33.40.197:7070/api/processes-deals/

- **Поля сущности:**  
  `GET {BASE_URL}/api/entity-meta-fields/?type={deal|contact|lead|smart_process}[&entity_key=sp:1114]`  
  Пример: http://194.33.40.197:7070/api/entity-meta-fields/?type=lead

- **Данные сущности (для грида):**  
  `GET {BASE_URL}/api/entity-meta-data/?type=...&limit=10000&offset=0[&entity_key=sp:1114]`  
  Пример: http://194.33.40.197:7070/api/entity-meta-data/?type=lead&limit=10000&offset=0  

  Максимум за один запрос: **limit=10000**. Чтобы показать все записи с пагинацией 10/25/50 на странице — загрузить все порции (offset=0, 10000, 20000, …), объединить `data`, затем пагинировать на фронте (раздел 4).

Для смарт-процессов параметр `entity_key` обязателен. Ошибки API возвращают HTTP 4xx/5xx и JSON с полем `detail`.

---

# 7. Хранение в БД (автосоздание таблиц)

- В коде **автоматически** создавать таблицы при старте приложения (если не существуют), через миграции или `db.create_all()` после определения моделей.
- **Таблица 1 — конфигурация грида** (например `entity_table_config`): хранить выбранные сущности и выбранные поля для страницы/сессии (page_slug или session_id, список сущностей `type`/`entity_key`/`category_id`, список `human_title` для колонок). Назначение: восстановление настроек при возврате на страницу.
- **Таблица 2 — шаблоны** (например `entity_table_template`): сохранять настроенный вариант как шаблон (название шаблона, список сущностей, список полей). Пользователь настраивает сущности и поля, нажимает «Сохранить как шаблон», вводит имя — запись в БД; позже можно выбрать шаблон из списка и применить (подставить сущности и поля).

---

# 8. Файлы для замены на сервере (после реализации)

После внедрения фичи на сервере нужно заменить/добавить:

| Файл | Действие |
|------|----------|
| `apps/pages/routes.py` | Заменить — добавлены маршруты прокси для API (`/api/processes-deals/`, `/api/entity-meta-fields/`, `/api/entity-meta-data/`) и при необходимости CRUD для конфигов/шаблонов |
| `apps/models.py` (или аналог) | Добавить — модели для таблиц конфигурации грида и шаблонов |
| `apps/__init__.py` | Проверить — импорт моделей перед `db.create_all()` |
| `apps/config.py` | При необходимости — переменная `CRM_API_BASE_URL` (или аналог) для базового URL API |
| `apps/templates/pages/entity-table.html` | Добавить — шаблон страницы таблицы сущностей (плюс, модалки, грид, пагинация) |
| `env.sample` | При необходимости — пример переменной для `CRM_API_BASE_URL` |

После копирования файлов: перезапуск сервиса, например `sudo systemctl restart universal_admin.service`. Если используется БД — при первом запуске таблицы создадутся автоматически.
